<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A basic Hello World HTML page with metadata and OpenGraph headers">
    <meta name="author" content="Your Name">
    <title>Hello World</title>
    
    <!-- OpenGraph Metadata -->
    <meta property="og:title" content="Hello World">
    <meta property="og:description" content="A basic Hello World HTML page with metadata and OpenGraph headers">
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://example.com">
    <meta property="og:image" content="http://example.com/image.jpg">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <style>
        body{
            margin: 0;
        }

        #remoteCapture{
            width: 100%;
        }

    </style>
</head>
<body>

    <img id="remoteCapture" src="/stream" oncontextmenu="return false;"></img>
   
    <script>
        let socket;
        let protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        let port = window.location.port ? window.location.port : (protocol === 'wss' ? 443 : 80);
        let socketURL = `${protocol}://${window.location.hostname}:${port}/hid`;
        let mouseMoveAbsolte = true; // Set to true for absolute mouse coordinates, false for relativeZ
        let mouseIsOutside = false;
        let mouseButtonState = [0, 0, 0]; // Array to track mouse button states, left, middle, right

        /* Mouse events */
        function handleMouseMove(event) {
            const mouseButtonBits = mouseButtonState.reduce((acc, state, index) => {
                return acc | (state << index);
            }, 0);
            const hidCommand = {
                event: 2,
                mouse_x: event.clientX,
                mouse_y: event.clientY,
                mouse_move_button_state: mouseButtonBits // Combine mouse button states into a single bitmask
            };



            const rect = event.target.getBoundingClientRect();
            const relativeX = event.clientX - rect.left;
            const relativeY = event.clientY - rect.top;
            
            if (relativeX < 0 || relativeY < 0 || relativeX > rect.width || relativeY > rect.height) {
                mouseIsOutside = true;
                return; // Mouse is outside the client rect
            }
            mouseIsOutside = false;
            const percentageX = (relativeX / rect.width) * 4096;
            const percentageY = (relativeY / rect.height) * 4096;

            hidCommand.mouse_x = Math.round(percentageX);
            hidCommand.mouse_y = Math.round(percentageY);

            console.log(`Mouse move: (${event.clientX}, ${event.clientY})`);
            console.log(`Mouse move relative: (${relativeX}, ${relativeY})`);
            console.log(`Mouse move percentage: (${hidCommand.mouse_x}, ${hidCommand.mouse_y})`);

            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(hidCommand));
            } else {
                console.error("WebSocket is not open.");
            }
        }
        

        function handleMousePress(event) {
            event.preventDefault();
            event.stopImmediatePropagation();
            if (mouseIsOutside) {
                console.warn("Mouse is outside the capture area, ignoring mouse press.");
                return;
            }
            const buttonMap = {
                0: 1, 
                1: 3,
                2: 2
            }; //Map javascript mouse buttons to HID buttons

            const hidCommand = {
                event: 3,
                mouse_button: buttonMap[event.button] || 0
            };

            // Update mouse button state
            if (event.button >= 0 && event.button < mouseButtonState.length) {
                mouseButtonState[event.button] = 1; // Set button state to pressed
            }
            // Log the mouse button state

            console.log(`Mouse down: ${hidCommand.mouse_button}`);

            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(hidCommand));
            } else {
                console.error("WebSocket is not open.");
            }
        }

        function handleMouseRelease(event) {
            event.preventDefault();
            event.stopImmediatePropagation();
            if (mouseIsOutside) {
                console.warn("Mouse is outside the capture area, ignoring mouse press.");
                return;
            }
            const buttonMap = {
                0: 1, 
                1: 3,
                2: 2
            }; //Map javascript mouse buttons to HID buttons
            
            const hidCommand = {
                event: 4,
                mouse_button: buttonMap[event.button] || 0
            };

            // Update mouse button state
            if (event.button >= 0 && event.button < mouseButtonState.length) {
                mouseButtonState[event.button] = 0; // Set button state to released
            }

            console.log(`Mouse release: ${hidCommand.mouse_button}`);

            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(hidCommand));
            } else {
                console.error("WebSocket is not open.");
            }
        }

        function handleMouseScroll(event) {
            const hidCommand = {
                event: 5,
                mouse_scroll: event.deltaY
            };
            if (mouseIsOutside) {
                console.warn("Mouse is outside the capture area, ignoring mouse press.");
                return;
            }


            console.log(`Mouse scroll: mouse_scroll=${event.deltaY}`);

            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(hidCommand));
            } else {
                console.error("WebSocket is not open.");
            }
        }

        // Attach mouse event listeners
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mousedown', handleMousePress);
        document.addEventListener('mouseup', handleMouseRelease);
        document.addEventListener('wheel', handleMouseScroll);

        /* Keyboard */
        function isNumpadEvent(event) {
            return event.location === 3;
        }

        function handleKeyDown(event) {
            event.preventDefault();
            event.stopImmediatePropagation();
            const key = event.key;
            let hidCommand = {
                event: 0,
                keycode: event.keyCode
            };

            console.log(`Key down: ${key} (code: ${event.keyCode})`);

            // Check if the key is a modkey on the right side of the keyboard
            const rightModKeys = ['Control', 'Alt', 'Shift', 'Meta'];
            if (rightModKeys.includes(key) && event.location === 2) {
                hidCommand.is_right_modifier_key = true;
            }else if (key === 'Enter' && isNumpadEvent(event)) {
                //Special case for Numpad Enter
                hidCommand.is_right_modifier_key = true;
            }else{
                hidCommand.is_right_modifier_key = false;
            }

            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(hidCommand));
            } else {
                console.error("WebSocket is not open.");
            }
        }

        function handleKeyUp(event) {
            event.preventDefault();
            event.stopImmediatePropagation();
            const key = event.key;
            
            let hidCommand = {
                event: 1,
                keycode: event.keyCode
            };

            console.log(`Key up: ${key} (code: ${event.keyCode})`);

            // Check if the key is a modkey on the right side of the keyboard
            const rightModKeys = ['Control', 'Alt', 'Shift', 'Meta'];
            if (rightModKeys.includes(key) && event.location === 2) {
                hidCommand.is_right_modifier_key = true;
            } else if (key === 'Enter' && isNumpadEvent(event)) {
                //Special case for Numpad Enter
                hidCommand.is_right_modifier_key = true;
            }else{
                hidCommand.is_right_modifier_key = false;
            }


            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(hidCommand));
            } else {
                console.error("WebSocket is not open.");
            }
        }

        /* Start and Stop events */
        function startWebSocket(){
            if (socket){
                //Already started
                alert("Websocket already started");
                return;
            }
            const socketUrl = socketURL;
            socket = new WebSocket(socketUrl);

            socket.addEventListener('open', function(event) {
                console.log('WebSocket is connected.');
            });

            socket.addEventListener('message', function(event) {
                console.log('Message from server ', event.data);
            });

            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
        }

        function stopWebSocket(){
            if (!socket){
                alert("No ws connection to stop");
                return;
            }

            socket.close();
            console.log('WebSocket is disconnected.');
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
        }


        $(document).ready(function(){
            startWebSocket();
        });
    </script>
</body>
</html>